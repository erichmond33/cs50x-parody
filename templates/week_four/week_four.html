{% extends "layout.html" %}

{% block title %}

<!DOCTYPE html><html lang="en-us">
<!-- Mirrored from cs50.harvard.edu/x/2020/weeks/4/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 19 Dec 2020 04:45:46 GMT -->
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:description" content="Introduction to the intellectual enterprises of computer science and the art of programming. This course teaches students how to think algorithmically and solve problems efficiently. Topics include abstraction, algorithms, data structures, encapsulation, resource management, security, and software engineering. Languages include C, Python, and SQL plus students' choice of: HTML, CSS, and JavaScript (for web development); Java or Swift (for mobile app development); or Lua (for game development). Problem sets inspired by the arts, humanities, social sciences, and sciences. Course culminates in a final project. Designed for concentrators and non-concentrators alike, with or without prior programming experience. Two thirds of CS50 students have never taken CS before. Among the overarching goals of this course are to inspire students to explore unfamiliar waters, without fear of failure, create an intensive, shared experience, accessible to all students, and build community among students.">

<meta property="og:image" content="https://img.youtube.com/vi/e9Eds2Rc_x8/maxresdefault.jpg"><meta property="og:title" content="Week 4 - CS50x"><link href="https://cs50.harvard.edu/x/2020/favicon.ico?1608231730" rel="icon">

<!-- https://fonts.google.com/specimen/PT+Sans?query=PT+Sans&selection.family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700 -->
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>

<!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
<script src="https://cs50.harvard.edu/x/2020/assets/jquery/dist/jquery.min.js?1608231730"></script>
<script src="https://cs50.harvard.edu/x/2020/assets/bootstrap/dist/js/bootstrap.bundle.min.js?1608231730"></script>

<!-- https://bootstrap-table.com/docs/getting-started/introduction/ -->
<link href="https://cs50.harvard.edu/x/2020/assets/bootstrap-table/dist/bootstrap-table.min.css?1608231730" rel="stylesheet">
<script src="https://cs50.harvard.edu/x/2020/assets/bootstrap-table/dist/bootstrap-table.min.js?1608231730"></script>
<script src="https://cs50.harvard.edu/x/2020/assets/bootstrap-table/dist/extensions/mobile/bootstrap-table-mobile.min.js?1608231730"></script>

<!-- https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use -->
<link href="https://cs50.harvard.edu/x/2020/assets/@fortawesome/fontawesome-free/css/all.min.css?1608231730" rel="stylesheet">

<!-- https://moment.github.io/luxon/ -->
<script src="https://cs50.harvard.edu/x/2020/assets/luxon.min.js?1608231730"></script>

<!-- http://docs.mathjax.org/ -->
<!-- https://www.jsdelivr.com/package/npm/mathjax?path=es5 -->
<script crossorigin="anonymous" integrity="sha256-+nfSJ1LiSvANSK3wvi6FjM+oFwoIQvURU1frozp5z6o=" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-chtml.js"></script>



<link href="https://cs50.harvard.edu/x/2020/assets/page.css?1608231730" rel="stylesheet">
<script src="https://cs50.harvard.edu/x/2020/assets/jekyll-theme-cs50.js?1608231730"></script>

<script>
    window.CS50 = {
        locale: "en",
        tz: "America/New_York"
    };
</script>

<title>Week 4 - CS50x</title>

{% endblock %}


{% block main %}

                <main class="col-md">

                    <ul class="nav">
                    <li class="nav-item">
                      <h1>Week 4</h1>
                    </li>
                    <li class="nav-item">
                      <h3><a class="nav-link active" href="/week_four#filter">Filter</a></h3>
                    </li>
                    <li class="nav-item">
                      <h3><a class="nav-link active" href="/week_four#recover">Recover</a></h3>
                    </li>
                  </ul>

  <!-- Filter --->

  <h2><a id="filter" href="/filter">Filter</a>&nbsp;&nbsp;&nbsp;<---- My Project!</h2>


<p>What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image.</p>

<h4 id="grayscale">Grayscale</h4>

<p>One common filter is the “grayscale” filter, where we take an image and want to convert it to black-and-white. How does that work?</p>

<p>Recall that if the red, green, and blue values are all set to <code class="language-plaintext highlighter-rouge">0x00</code> (hexadecimal for <code class="language-plaintext highlighter-rouge">0</code>), then the pixel is black. And if all values are set to <code class="language-plaintext highlighter-rouge">0xff</code> (hexadecimal for <code class="language-plaintext highlighter-rouge">255</code>), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black).</p>

<p>So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it’s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low.</p>


<h4 id="reflection">Reflection</h4>

<p>Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa.</p>

<p>Note that all of the original pixels of the original image will still be present in the reflected image, it’s just that those pixels may have rearranged to be in a different place in the image.</p>

<h4 id="blur">Blur</h4>

<p>There are a number of ways to create the effect of blurring or softening an image. For this problem, we’ll use the “box blur,” which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels.</p>

<h4 id="edges">Edges</h4>

<p>In artificial intelligence algorithms for image processing, it is often useful to detect edges in an image: lines in the image that create a boundary between one object and another. One way to achieve this effect is by applying the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a> to the image.</p>

<p>Like image blurring, edge detection also works by taking each pixel, and modifying it based on the 3x3 grid of pixels that surrounds that pixel. But instead of just taking the average of the nine pixels, the Sobel operator computes the new value of each pixel by taking a weighted sum of the values for the surrounding pixels. And since edges between objects could take place in both a vertical and a horizontal direction, you’ll actually compute two weighted sums: one for detecting edges in the x direction, and one for detecting edges in the y direction.</p>

<h3>Implementation</h3>

<p>Implement a program that applies the filters grayscale, reflection, blur, and edges to BMPs.</h3>

 <!-- recover --->

  <h2><a id="recover" href="/recover">Recover</a>&nbsp;&nbsp;&nbsp;<---- My Project!</h2>

<p>In anticipation of this problem, we spent the past several days taking photos of people we know, all of which were saved on a digital camera as JPEGs on a memory card. (Okay, it’s possible we actually spent the past several days on Facebook instead.) Unfortunately, we somehow deleted them all! Thankfully, in the computer world, “deleted” tends not to mean “deleted” so much as “forgotten.” Even though the camera insists that the card is now blank, we’re pretty sure that’s not quite true. Indeed, we’re hoping (er, expecting!) you can write a program that recovers the photos for us!</p>

<p>Even though JPEGs are more complicated than BMPs, JPEGs have “signatures,” patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xff 0xd8 0xff
</code></pre></div></div>

<p>from first byte to third byte, left to right. The fourth byte, meanwhile, is either <code class="language-plaintext highlighter-rouge">0xe0</code>, <code class="language-plaintext highlighter-rouge">0xe1</code>, <code class="language-plaintext highlighter-rouge">0xe2</code>, <code class="language-plaintext highlighter-rouge">0xe3</code>, <code class="language-plaintext highlighter-rouge">0xe4</code>, <code class="language-plaintext highlighter-rouge">0xe5</code>, <code class="language-plaintext highlighter-rouge">0xe6</code>, <code class="language-plaintext highlighter-rouge">0xe7</code>, <code class="language-plaintext highlighter-rouge">0xe8</code>, <code class="language-plaintext highlighter-rouge">0xe9</code>, <code class="language-plaintext highlighter-rouge">0xea</code>, <code class="language-plaintext highlighter-rouge">0xeb</code>, <code class="language-plaintext highlighter-rouge">0xec</code>, <code class="language-plaintext highlighter-rouge">0xed</code>, <code class="language-plaintext highlighter-rouge">0xee</code>, or <code class="language-plaintext highlighter-rouge">0xef</code>. Put another way, the fourth byte’s first four bits are <code class="language-plaintext highlighter-rouge">1110</code>.</p>

<p>Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn’t an exact science.</p>

<p>Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose “block size” is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that’s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 ÷ 512 = 2048 “blocks” on a memory card. But so does a photo that’s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called “slack space.” Forensic investigators often look at slack space for remnants of suspicious data.</p>

<p>The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs’ signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card’s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency’s sake. Thanks to FAT, you can trust that JPEGs’ signatures will be “block-aligned.” That is, you need only look for those signatures in a block’s first four bytes.</p>

<p>Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it’d been “zeroed” (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It’s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable.</p>

<p>Now, I only have one memory card, but there are a lot of you! And so I’ve gone ahead and created a “forensic image” of the card, storing its contents, byte after byte, in a file called <code class="language-plaintext highlighter-rouge">card.raw</code>. So that you don’t waste time iterating over millions of 0s unnecessarily, I’ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs.</p>

                </main>

            </div>

        </div>






</body>
<!-- Mirrored from cs50.harvard.edu/x/2020/weeks/4/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 19 Dec 2020 04:45:46 GMT -->
</html>

{% endblock %}